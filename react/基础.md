# React 基础

## 生命周期

- constructor
- componentDidMount
- componentDidCatch
- componentDidUpdate
- shouldComponentUpdate
- getDerivedStateFromProps(nextProps, prevState)

## VDOM diff 算法

virtual Dom 就是一个 js 的对象，是虚拟的 dom。
在 react 中，每次 setState 之后 react 都会生成一个新的 vdom tree，与旧的 tree 进行 diff 比较，得到差异的地方之后一次性 patch 到真实的 dom 上。

- 按 tree 的层级 diff
- 按类型进行 diff<组件的类型>
- 按列表进行 diff<设置 key 可以提高 diff 的效率>

## setState 同异步的问题

在原生事件（原生自带的事件监听，addEventListener，或者直接操作原生 js 获取 dom 节点对其绑定事件）中是同步的。  
在 react class 中的合成事件，生命周期事件中 setState 是异步的。  
在 setTimeout 里的 setState 因为 event loop 的原因，总是同步的。因为 setTimeout 会放在单独的队列里，等到队列执行完毕，isBatchingUpdate（react 中 setState 里的一个标志）已经是 false 了，这个时候就会是同步的表现。  
所谓的异步是因为调用顺序在更新之前，导致无法立即拿到最新的值。但是可以通过 callback 拿到更新后的结果。

## react 的 virtual dom 与双缓冲机制

virtual dom 其实就是一个 js 对象，因为直接操作 dom 元素的开销比较大，react 为了提高效率，在渲染的时候会先建立 2 个 fiber tree，一个是 current，一个是 workInProgress。修改会先在 workInProgress 的树上进行，改完之后再进行页交换，这是双缓冲机制，可以避免渲染出现抖动。

## react diff

react 的渲染分为 2 个步骤，一个是 reconciliation，一个是 commit，reconciliation 是处理更新，标出当前更新中哪些 fiber 节点需要更新，并将这些节点放到 sideEffect 这个线性表里，方变快速处理。这个过程是可中断的，因为如果当前节点过多，可能会出现卡顿的现象。一个就是 commit 阶段，将处理好的改动一次性更新到真实 dom 节点上，这个过程是无法中断的。

在处理更新的时候会现在 workInProgress tree 上进行一系列的标识修改，这个过程实际上就是如何一棵树如何变动到另一棵树的算法，传统的 diff 算法的复杂度是 O(n^3)，react 做了巧妙的约定策略：同一层级下 type 和 key 若是不同，则该节点直接删掉重新生成，将复杂度降到了 O(n)，大大的提升了 diff 的性能。

reconciliation 的可中断在老的版本中是通过 expirationTime 来实现的，每个任务会有一个过期时间，几个过期时间相近的任务会被合并到一次更新中，如果到了过期时间还没执行就强制执行，如果还没到的话就可以等浏览器有空了再执行。浏览器什么时候有空是通过 requestIdleCallback 来实现的。但是因为 rIC 的 FPS 只有 20，react 为了规避这个缺点，自行实现了一套支持不高于 120FPS 的 rIC（再高就出 bug 了），是通过 rAF + window.postMessage 实现的，
