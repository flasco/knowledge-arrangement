# 事件循环

JavaScript 是单线程语言，处理事件分宏任务/微任务，主要的执行框架是这样的。

```ts
for (const macroTask of macroTaskQueue) {
  handleMacroTask();

  for (const microTask of microTaskQueue) {
    handleMicroTask(microTask);
  }
}
```

在执行微任务的时候插入了新的微任务，会一直执行，直到执行完微任务为止。

- macro-task(宏任务)：包括整体代码 script，setTimeout，setInterval，MessageChannel，postMessage，UI rendering，I/O
- micro-task(微任务)：Promise.then/catch，process.nextTick，MutationObserver

> tips: Promise 的 constructor 是同步执行的。

然后附一道阿里真题(狗头)

```js

// 首先是一个父子box，在这上面分别绑定两个listener
var outer = document.querySelector('.outer');
var inner = document.querySelector('.inner');

new MutationObserver(function () {
  console.log('mutate');
}).observe(outer, {
  attributes: true,
});

function onClick() {
  console.log('click');

  setTimeout(function () {
    console.log('timeout');
  }, 0);

  Promise.resolve().then(function () {
    console.log('promise');
  });

  outer.setAttribute('data-random', Math.random());
}

// …which we'll attach to both elements
inner.addEventListener('click', onClick);
outer.addEventListener('click', onClick);
})

// 解释为什么输出是这样的
// click
// promise
// mutate
// click
// promise
// mutate
// timeout
// timeout
```

其实原则套这上面就好了，先宏再微，循环。

一开始点击的时候会触发两个点击事件，只不过一开始先执行 child 的 click 事件，再执行
先执行 father 的 click 事件，这时候宏任务的两个 task 就确认了。然后开始执行 child 的事件，按照先宏再微的方案，执行完代码之后，触发微任务循环，setTimeout 是宏任务，就 push 到宏任务队列里，在 father 之后执行，这就是为什么 timeout 在最后执行的原因。
